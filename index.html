<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Property Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <style>
    :root{
      --main:#93c47d;       /* header / brand (darker green) */
      --secondary:#b6d7a8;  /* middle green */
      --accent:#d9ead3;     /* lightest green (cards / popups) */
      --sea:#0fa8d2;        /* page/map bg (ocean) */
      --ink:#111; --muted:#666; --paper:#fff;
    }
    html,body{ height:100%; margin:0; background:var(--sea); }
    .leaflet-container{ background:var(--sea); }

    /* Layout */
    #map{ position:absolute; inset:56px 0 0 0; display:none; }
    #toolbar{
      position:fixed; inset:0 0 auto 0; height:56px;
      display:flex; gap:12px; align-items:center; padding:8px 12px;
      background:var(--main); color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      z-index:1000; box-shadow:0 2px 8px rgba(0,0,0,.2);
    }
    #brand{ display:flex; align-items:center; gap:8px; }
    #brand img{ height:36px; width:auto; display:block; }
    #toolbar label{ display:flex; align-items:center; gap:6px; }
    #toolbar input[type="checkbox"]{ transform:translateY(1px); }
    #toolbar button{
      border:none; padding:8px 12px; border-radius:8px; cursor:pointer;
      background:#fff; color:#111; font-weight:700;
    }
    #toolbar button:hover{ filter:brightness(.97); color:#111; }

    /* Badges */
    #status{
      position:fixed; bottom:8px; left:10px; font:13px/1.3 system-ui; color:#111;
      background:rgba(255,255,255,.9); padding:4px 8px; border-radius:6px; z-index:1200;
      box-shadow:0 2px 6px rgba(0,0,0,.15);
    }
    #version{
      position:fixed; bottom:8px; right:10px; font:12px/1 monospace;
      color:rgba(255,255,255,.92); background:rgba(0,0,0,.6);
      padding:2px 6px; border-radius:4px; z-index:1200;
    }

    /* Settings menu */
    #settings{ margin-left:auto; position:relative; }
    #settingsBtn{ background:#fff; color:#111; }
    #settingsMenu{
      position:absolute; right:0; top:44px; min-width:260px;
      background:#fff; color:#111; border-radius:10px;
      box-shadow:0 12px 24px rgba(0,0,0,.2);
      display:none; overflow:hidden; z-index:1400;
    }
    #settingsMenu button{
      display:block; width:100%; text-align:left; padding:10px 12px;
      border:0; background:transparent; cursor:pointer; color:#111;
    }
    #settingsMenu button:hover{ background:#f2f2f2; color:#111; }

    /* Modals (styles kept) */
    .modal{ position:fixed; inset:0; display:grid; place-items:center;
      background:rgba(0,0,0,.45); z-index:1500; opacity:0; pointer-events:none; transition:opacity .18s ease; }
    .modal.show{ opacity:1; pointer-events:auto; }
    .card{
      width:min(560px, calc(100vw - 24px)); max-height:85vh; overflow:auto;
      background:var(--secondary); color:var(--ink); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.25);
      font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      transform:translateY(6px); transition:transform .18s ease;
    }
    .modal.show .card{ transform:translateY(0); }
    .card header{ padding:12px 14px; background:var(--main); border-radius:12px 12px 0 0; font-weight:700; position:relative; }
    .card main{ padding:14px; display:grid; gap:12px; background:var(--accent); }
    .card footer{ padding:12px 14px; background:var(--secondary); border-radius:0 0 12px 12px; display:flex; gap:8px; justify-content:flex-end; }
    .modal .btn{ border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.primary{ background:#111; color:#fff; }
    .btn.ghost{ background:#eee; color:#111; }

    /* Popup restyle */
    .leaflet-popup-content-wrapper{ background:var(--accent); border:2px solid var(--main); border-radius:10px; }
    .leaflet-popup-tip{ background:var(--accent); }
    .popup h3{
      margin:0 0 6px 0; font-size:16px; color:#111;
      background:var(--main); padding:4px 6px; border-radius:6px; display:inline-block;
    }
    .popup p{ margin:0 0 6px; }
    .popup small{ color:#333; display:block; margin-top:6px; }
    .popup a{ color:#003366; font-weight:600; text-decoration:none; border-bottom:1px solid transparent; }
    .popup a:hover{ border-bottom-color:#003366; }

    /* Controls position (zoom bottom-left) */
    .leaflet-control-zoom{
      position:absolute !important; left:10px !important; bottom:48px !important;
      top:auto !important; margin:0 !important;
    }

    /* Area name label style */
    .area-label{
      background:rgba(255,255,255,.85);
      padding:2px 6px; border-radius:6px; font:12px/1.2 system-ui; color:#111;
      border:1px solid rgba(0,0,0,.1); white-space:nowrap;
    }

    /* Overlay toggle (right side button) */
    .leaflet-control.overlay-toggle a{
      display:block; width:auto; min-width:84px; text-align:center;
      background:#fff; color:#111; border-radius:8px; padding:8px 10px;
      font:13px/1.2 system-ui; text-decoration:none; border:1px solid #ddd;
      box-shadow:0 2px 6px rgba(0,0,0,.15);
    }
    .leaflet-control.overlay-toggle a:hover{ background:#f7f7f7; }
    .leaflet-control.overlay-toggle a.active{
      background:var(--secondary); border-color:#a6c99c;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div id="brand">
      <img src="Dynasty8-GTAV-Logo.png" alt="Dynasty 8">
      <strong>Property Map</strong>
    </div>

    <!-- Hidden until unlocked -->
    <label id="addWrap" style="display:none" title="Enable click-to-add mode"><input type="checkbox" id="addMode"> Add</label>
    <label id="editWrap" style="display:none" title="Enable drag/edit mode"><input type="checkbox" id="editMode"> Edit</label>

    <button id="unlockBtn" title="Enter password to edit">Unlock</button>
    <button id="lockBtn" style="display:none" title="Lock editing">Lock</button>

    <span id="hint">Loading…</span>

    <div id="settings">
      <button id="settingsBtn" title="Open settings">⚙️ Settings</button>
      <div id="settingsMenu" role="menu" aria-hidden="true">
        <button id="menuExport"      title="Download markers.json">Export markers</button>
        <button id="menuChangelog"   title="View recent commits">Changelog</button>
        <button id="menuStats"       title="Totals & last updated">Statistics</button>
        <button id="menuToggleAreas" title="Show/hide area names">Toggle area names</button>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div id="status">Loading map…</div>
  <div id="version"></div>

  <!-- (Keep your existing Add/Edit/Changelog/Stats modals here — unchanged) -->

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, signInAnonymously, signOut } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import {
      getFirestore, collection, onSnapshot, addDoc, doc, updateDoc, deleteDoc, serverTimestamp,
      enableIndexedDbPersistence, getDocsFromCache, getDocsFromServer
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

    // ===== Build / Version =====
    const VERSION = "beta 1.1.0";
    const VERSION_NOTE = "Zoning overlay toggle (right-side button) + Area names toggle (Settings).";
    document.getElementById("version").textContent = VERSION;
    console.log("Dynasty 8 Map — " + VERSION + " — " + VERSION_NOTE);

    // ===== Firebase =====
    const firebaseConfig = {
      apiKey: "AIzaSyCcfOML9FD1Q5vcoCb3NdIlFKtx3LAovBc",
      authDomain: "dynasty8-property-map.firebaseapp.com",
      projectId: "dynasty8-property-map",
      storageBucket: "dynasty8-property-map.firebasestorage.app",
      messagingSenderId: "849316207524",
      appId: "1:849316207524:web:9c921ad842fc188d027f31",
      measurementId: "G-VXG629H337"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // Auto sign in anonymously so reads always work
    try { await signInAnonymously(auth); } catch(e){ console.warn("[auth] anon failed:", e?.message||e); }
    try { await enableIndexedDbPersistence(db); } catch(e){ console.warn("[fs] persistence:", e?.message||e); }

    // ===== DOM refs =====
    const addModeEl  = document.getElementById("addMode");
    const editModeEl = document.getElementById("editMode");
    const addWrap    = document.getElementById("addWrap");
    const editWrap   = document.getElementById("editWrap");
    const unlockBtn  = document.getElementById("unlockBtn");
    const lockBtn    = document.getElementById("lockBtn");
    const hintEl     = document.getElementById("hint");
    const statusEl   = document.getElementById("status");
    const mapEl      = document.getElementById("map");

    const settingsBtn   = document.getElementById("settingsBtn");
    const settingsMenu  = document.getElementById("settingsMenu");
    const menuExport    = document.getElementById("menuExport");
    const menuChangelog = document.getElementById("menuChangelog");
    const menuStats     = document.getElementById("menuStats");
    const menuToggleAreas = document.getElementById("menuToggleAreas");

    // ===== Config & State =====
    const LOCAL_EDIT_PASSWORD = "D8D8D8";
    const MAP_CANDIDATES = ["map.jpg","map.jpeg","map.png"];
    let unlocked = false;
    let map, currentIconSize = 32;
    let imageWidth = 0, imageHeight = 0;

    // Layers
    const groups = {
      apartment: L.layerGroup(), penthouse: L.layerGroup(),
      office: L.layerGroup(), motel: L.layerGroup()
    };
    const markers = new Map(); // id -> { ... , _marker }
    let latestUpdatedAtMillis = 0;

    // Optional layers
    let zonesOverlay = null;                 // overlay.png image overlay
    const areaLabelsLayer = L.layerGroup();  // area name labels

    function toast(m){ hintEl.textContent = m; }

    // ===== Icons by type =====
    function iconFor(entry, size){
      const t = (entry.type || "apartment").toLowerCase();
      const files = {
        apartment: "house-apartment.png",
        penthouse: "house-penthouse.png",
        office:    "house-office.png",
        motel:     "house-motel.png"
      };
      const s = size || currentIconSize;
      return L.icon({ iconUrl: files[t] || files.apartment, iconSize:[s,s], iconAnchor:[s/2,s/2], tooltipAnchor:[0,-s/2] });
    }

    // ===== Links rendering (same as 1.0.9) =====
    function entryLinks(entry){
      if (entry?.links?.length) return entry.links;
      const arr = [];
      if (entry?.shabby) arr.push({ label:"Shabby Apartment", url:entry.shabby });
      if (entry?.nice)   arr.push({ label:"Nice Apartment",   url:entry.nice });
      return arr;
    }
    function renderLinksHTML(entry){
      const t = (entry.type || "apartment").toLowerCase();
      const links = entryLinks(entry);
      if (t === "apartment"){
        let shabby=null, nice=null;
        for (let i=0;i<links.length;i++){ if (!shabby && /shabby/i.test(links[i].label)) shabby=links[i]; if (!nice && /nice/i.test(links[i].label)) nice=links[i]; }
        return (shabby?`<p><a href="${shabby.url}" target="_blank" rel="noopener">Shabby Apartment</a></p>`:"") +
               (nice?  `<p><a href="${nice.url}"   target="_blank" rel="noopener">Nice Apartment</a></p>`  :"");
      }
      if (t === "office"){ const link = links[0]; return link?`<p><a href="${link.url}" target="_blank" rel="noopener">Office</a></p>`:""; }
      if (t === "motel"){
        const link = links[0];
        const note = '<div style="color:#d60000;font-weight:700;margin-top:6px">Don’t use this link in your listing, you need a door photo!</div>';
        return (link?`<p><a href="${link.url}" target="_blank" rel="noopener">Album</a></p>`:"")+note;
      }
      if (t === "penthouse"){
        let html=""; for (let j=0;j<links.length;j++){ const Lk=links[j]; html += `<p><a href="${Lk.url||''}" target="_blank" rel="noopener">${Lk.label||"Album"}</a></p>`; }
        return html;
      }
      let out=""; for (let k=0;k<links.length;k++){ const lk=links[k]; out += `<p><a href="${lk.url||''}" target="_blank" rel="noopener">${lk.label||"Link"}</a></p>`; }
      return out;
    }

    function setMarkerPopup(entry){
      const html =
        `<div class="popup">
          <h3>${entry.name || "Property"}</h3>
          <p><strong>Type:</strong> ${entry.type || "apartment"}</p>
          ${renderLinksHTML(entry)}
          <small>Coords: x=${entry.x.toFixed(1)}, y=${entry.y.toFixed(1)}</small>
          ${ (unlocked && editModeEl.checked)
              ? '<div style="margin-top:6px;display:flex;gap:8px">' +
                  '<button class="btn" data-action="edit" style="padding:4px 8px;background:#eee;border-radius:6px">Edit</button>' +
                  '<button class="btn" data-action="delete" style="padding:4px 8px;background:#eee;border-radius:6px">Delete</button>' +
                '</div>'
              : '' }
        </div>`;
      entry._marker.bindPopup(html);

      entry._marker.off('popupopen').on('popupopen', (e) => {
        if (!(unlocked && editModeEl.checked)) return;
        const el = e.popup.getElement(); if (!el) return;
        const editBtn = el.querySelector('[data-action="edit"]');
        const delBtn  = el.querySelector('[data-action="delete"]');
        if (editBtn) editBtn.addEventListener('click', () => openEditModal(entry));
        if (delBtn) delBtn.addEventListener('click', async () => {
          if (!confirm("Delete this marker?")) return;
          await deleteDoc(doc(db, "markers", entry.id));
        });
      });
    }

    function applyEditMode(){
      const canEdit = unlocked && editModeEl.checked;
      markers.forEach(m => {
        if (m._marker) {
          if (canEdit && m._marker.dragging) m._marker.dragging.enable();
          else if (m._marker.dragging) m._marker.dragging.disable();
          setMarkerPopup(m);
        }
      });
      toast(canEdit ? "Edit mode ON" : (unlocked ? "Edit mode OFF" : "Locked (view-only)"));
    }
    function setLockedUI(lock){
      unlocked = !lock;
      document.getElementById("unlockBtn").style.display = lock ? "" : "none";
      document.getElementById("lockBtn").style.display   = lock ? "none" : "";
      addWrap.style.display   = lock ? "none" : "";
      editWrap.style.display  = lock ? "none" : "";
      if (lock) editModeEl.checked = false;
      applyEditMode();
      toast(lock ? "Locked (view-only)" : "Edit unlocked");
    }

    // ===== Map (single image; tiles skipped) =====
    function init(imageUrl, w, h){
      imageWidth = w; imageHeight = h;
      const bounds = L.latLngBounds([[0,0],[h,w]]);
      map = L.map("map", { crs:L.CRS.Simple, minZoom:-2, maxZoom:5, zoomControl:true, attributionControl:false });
      L.imageOverlay(imageUrl, bounds).addTo(map);
      map.fitBounds(bounds);
      mapEl.style.display = "block";
      statusEl.textContent = "Image map loaded";

      // Marker groups
      groups.apartment.addTo(map); groups.penthouse.addTo(map);
      groups.office.addTo(map); groups.motel.addTo(map);

      // Icon scale on zoom
      map.on("zoomend", () => {
        const z = map.getZoom();
        currentIconSize = Math.max(16, Math.min(48, z * 4));
        markers.forEach(m => { if (m._marker) m._marker.setIcon(iconFor(m)); });
      });

      // Add marker flow
      map.on("click", (e) => {
        if (!(unlocked && addModeEl.checked)) return;
        if (document.querySelector("#addModal.show")) return;
        openAddModal(e.latlng);
      });

      // Right-side Overlay toggle control
      const OverlayControl = L.Control.extend({
        position: 'topright',
        onAdd: function(){
          const div = L.DomUtil.create('div', 'leaflet-control overlay-toggle');
          const a = L.DomUtil.create('a', '', div);
          a.href = '#'; a.title = 'Toggle zoning overlay'; a.textContent = 'Overlay';
          L.DomEvent.on(a, 'click', L.DomEvent.stop)
            .on(a, 'click', () => {
              if (!zonesOverlay){ toast('No overlay found.'); return; }
              if (map.hasLayer(zonesOverlay)){ map.removeLayer(zonesOverlay); a.classList.remove('active'); toast('Zones overlay hidden'); }
              else { zonesOverlay.addTo(map); a.classList.add('active'); toast('Zones overlay shown'); }
            });
          return div;
        }
      });
      map.addControl(new OverlayControl());

      // Lock UI, load optional layers, then data
      setLockedUI(true);
      tryLoadOverlay();
      tryLoadAreas();
      wireData();
    }

    // Single-image loader
    function tryLoadImage(i=0){
      if (i >= MAP_CANDIDATES.length){
        statusEl.textContent = "Could not find map.jpg/jpeg/png next to index.html.";
        return;
      }
      const src = MAP_CANDIDATES[i] + "?v=" + Date.now();
      const img = new Image();
      img.onload = () => init(src, img.naturalWidth, img.naturalHeight);
      img.onerror = () => tryLoadImage(i+1);
      img.src = src;
    }

    // Overlay loader (overlay.png)
    function tryLoadOverlay(){
      const test = new Image();
      test.onload = () => {
        const bounds = L.latLngBounds([[0,0],[imageHeight, imageWidth]]);
        zonesOverlay = L.imageOverlay("overlay.png?v="+Date.now(), bounds, { opacity:0.85, interactive:false });
        // Not added by default; the button toggles it on
      };
      test.onerror = () => console.log("[zones] overlay.png not found (optional)");
      test.src = "overlay.png?v="+Date.now();
    }

    // Area names loader (areas.json)
    async function tryLoadAreas(){
      try {
        const res = await fetch("areas.json?v="+Date.now(), { cache:"no-store" });
        if (!res.ok) throw new Error(res.status);
        const areas = await res.json(); // expected: [{ name, x, y }, ...]
        if (!Array.isArray(areas)) throw new Error("areas.json must be an array");

        areaLabelsLayer.clearLayers();
        areas.forEach(a => {
          if (typeof a.x !== "number" || typeof a.y !== "number" || !a.name) return;
          const icon = L.divIcon({ className:"area-label", html: a.name, iconSize: null });
          L.marker([a.y, a.x], { icon, interactive:false }).addTo(areaLabelsLayer);
        });
        // Hidden by default; toggle via Settings
      } catch (e){
        console.log("[areas] areas.json not found or invalid (optional)");
      }
    }

    // ===== Data: cache-first + live updates (same as 1.0.9) =====
    const markersCol = collection(db, "markers");

    function layerFor(type){
      const t = (type || "apartment").toLowerCase();
      if (t === "penthouse") return groups.penthouse;
      if (t === "office")    return groups.office;
      if (t === "motel")     return groups.motel;
      return groups.apartment;
    }
    function createOrUpdateMarker(entry){
      let m = markers.get(entry.id);
      const t = (entry.type || "apartment").toLowerCase();
      if (!m){
        m = { ...entry };
        m._marker = L.marker([m.y, m.x], {
          draggable: !!(unlocked && editModeEl.checked), autoPan: true, icon: iconFor(m)
        }).bindTooltip(m.name || "Property", {direction:"top", offset:[0,-10]});
        layerFor(t).addLayer(m._marker);
        markers.set(entry.id, m);
        setMarkerPopup(m);
        m._marker.on('dragend', async (e) => {
          const pos = e.target.getLatLng();
          await updateDoc(doc(db, "markers", m.id), { y: pos.lat, x: pos.lng, updatedAt: serverTimestamp() });
        });
      } else {
        const oldType = (m.type || "apartment").toLowerCase();
        if (oldType !== t && m._marker){ layerFor(oldType).removeLayer(m._marker); layerFor(t).addLayer(m._marker); }
        m.name = entry.name; m.x = entry.x; m.y = entry.y; m.type = entry.type;
        m.links = entry.links; m.shabby = entry.shabby; m.nice = entry.nice; m.updatedAt = entry.updatedAt || m.updatedAt || 0;
        if (m._marker){
          m._marker.setLatLng([m.y, m.x]); m._marker.setIcon(iconFor(m));
          if (m._marker.setTooltipContent) m._marker.setTooltipContent(m.name || "Property");
          setMarkerPopup(m);
        }
      }
      if (m.updatedAt && m.updatedAt > latestUpdatedAtMillis) latestUpdatedAtMillis = m.updatedAt;
    }
    function removeMarker(id){
      const m = markers.get(id);
      if (m && m._marker){ layerFor(m.type).removeLayer(m._marker); }
      markers.delete(id);
    }

    async function wireData(){
      // Cache first
      try {
        const cached = await getDocsFromCache(markersCol);
        if (!cached.empty){
          cached.forEach(d => {
            const v = d.data()||{}; let ms=0;
            if (v.updatedAt){ try {
              if (typeof v.updatedAt.toDate === "function") ms = v.updatedAt.toDate().getTime();
              else if (v.updatedAt.seconds) ms = v.updatedAt.seconds*1000 + Math.floor((v.updatedAt.nanoseconds||0)/1e6);
            } catch{} }
            createOrUpdateMarker({ id:d.id, name:v.name||"Property", x:v.x, y:v.y, type:v.type||"apartment",
              links:Array.isArray(v.links)?v.links:[], shabby:v.shabby||"", nice:v.nice||"", updatedAt:ms });
          });
          statusEl.textContent = "Loaded " + markers.size + " properties (cache)";
          hintEl.textContent = "Syncing…";
          map.fire("zoomend");
        }
      } catch {}

      // Server prefetch if needed
      if (markers.size === 0){
        try {
          const serverSnap = await getDocsFromServer(markersCol);
          if (!serverSnap.empty){
            serverSnap.forEach(d => {
              const v = d.data()||{}; let ms=0;
              if (v.updatedAt){ try {
                if (typeof v.updatedAt.toDate === "function") ms = v.updatedAt.toDate().getTime();
                else if (v.updatedAt.seconds) ms = v.updatedAt.seconds*1000 + Math.floor((v.updatedAt.nanoseconds||0)/1e6);
              } catch{} }
              createOrUpdateMarker({ id:d.id, name:v.name||"Property", x:v.x, y:v.y, type:v.type||"apartment",
                links:Array.isArray(v.links)?v.links:[], shabby:v.shabby||"", nice:v.nice||"", updatedAt:ms });
            });
            statusEl.textContent = "Loaded " + markers.size + " properties (server)";
            hintEl.textContent = "Ready";
            map.fire("zoomend");
          }
        } catch(e){ console.warn("[fs] server prefetch:", e?.message||e); }
      }

      // Live updates
      onSnapshot(markersCol, {
        includeMetadataChanges: true,
        next: (snap) => {
          let changed=false;
          snap.docChanges().forEach(chg => {
            const d = chg.doc, v=d.data()||{}; let ms=0;
            if (v.updatedAt){ try {
              if (typeof v.updatedAt.toDate === "function") ms = v.updatedAt.toDate().getTime();
              else if (v.updatedAt.seconds) ms = v.updatedAt.seconds*1000 + Math.floor((v.updatedAt.nanoseconds||0)/1e6);
            } catch{} }
            const entry = { id:d.id, name:v.name||"Property", x:v.x, y:v.y, type:v.type||"apartment",
              links:Array.isArray(v.links)?v.links:[], shabby:v.shabby||"", nice:v.nice||"", updatedAt:ms };
            if (chg.type==="added" || chg.type==="modified"){ createOrUpdateMarker(entry); changed=true; }
            else if (chg.type==="removed"){ removeMarker(d.id); changed=true; }
            if (ms && ms > latestUpdatedAtMillis) latestUpdatedAtMillis = ms;
          });
          if (changed){
            statusEl.textContent = "Loaded " + markers.size + " properties";
            map.fire("zoomend");
          }
          if (!snap.metadata.fromCache) hintEl.textContent = "Ready";
        },
        error: (err) => {
          console.error("[firestore] onSnapshot error:", err);
          statusEl.textContent = "Firestore error: " + (err?.message || err);
          hintEl.textContent = "Check Firestore rules / auth";
        }
      });
    }

    // ===== Settings actions =====
    settingsBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const open = settingsMenu.style.display === "block";
      settingsMenu.style.display = open ? "none" : "block";
    });
    document.addEventListener("click", () => { settingsMenu.style.display = "none"; });

    // Export
    menuExport.addEventListener("click", () => {
      settingsMenu.style.display = "none";
      const arr = [];
      markers.forEach(m => {
        arr.push({ name:m.name, x:m.x, y:m.y, type:m.type, links:m.links, shabby:m.shabby, nice:m.nice });
      });
      const blob = new Blob([JSON.stringify(arr, null, 2)], { type:"application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = "markers.json";
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    });

    // Area labels toggle (shown/hidden via Settings)
    document.getElementById("menuToggleAreas").addEventListener("click", () => {
      settingsMenu.style.display = "none";
      if (map.hasLayer(areaLabelsLayer)) { map.removeLayer(areaLabelsLayer); toast("Area names hidden"); }
      else { areaLabelsLayer.addTo(map); toast("Area names shown"); }
    });

    // ===== Unlock/lock =====
    document.getElementById("unlockBtn").addEventListener("click", async () => {
      const pass = prompt("Password:"); if (pass !== LOCAL_EDIT_PASSWORD){ alert("Wrong password."); return; }
      try { if (!auth.currentUser) await signInAnonymously(auth); } catch {}
      setLockedUI(false);
    });
    document.getElementById("lockBtn").addEventListener("click", async () => { try { await signOut(auth); } catch{} setLockedUI(true); });
    document.getElementById("editMode").addEventListener("change", applyEditMode);

    // ===== Boot =====
    function boot(){ tryLoadImage(); }
    boot();
  </script>
</body>
</html>
